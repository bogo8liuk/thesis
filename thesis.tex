\documentclass[10pt,a4paper]{article}
\usepackage[italian]{babel}
\usepackage{newlfont}
\usepackage{listings}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{hyperref}

\lstset{
    language=Haskell,
    basicstyle={\small\ttfamily}
}

\tikzstyle{process} =
    [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=white!30]
\tikzstyle{object} =
    [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=white!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\textwidth=450pt\oddsidemargin=0pt

\begin{document}
\begin{titlepage}

\begin{center}

{{\Large {\textsc {Alma Mater Studiorum $\cdot$ Universit\`a di Bologna}}}} \rule[0.1cm]{15.8cm}{0.1mm}

\rule[0.5cm]{15.8cm}{0.6mm}
{\small {\bf SCUOLA DI SCIENZE\\
Corso di Laurea in Nome corso di Laurea }}

\end{center}

\vspace{15mm}
\begin{center}

{\LARGE
    {\bf COMPILATORE PER LINGUAGGIO DI}
}\\
\vspace{3mm}
{\LARGE
    {\bf PROGRAMMAZIONE FUNZIONALE}
}\\
\vspace{3mm}
{\LARGE
    {\bf SPERIMENTALE}
}\\

\end{center}

\vspace{40mm}
\par
\noindent
\begin{minipage}[t]{0.47\textwidth}

{\large
    {\bf Relatore:\\
        Chiar.mo Prof.\\
        CLAUDIO SACERDOTI COEN
    }
}

\end{minipage}

\hfill
\begin{minipage}[t] {0.47\textwidth}\raggedleft
{\large
    {\bf Presentata da:\\
        LUCA BORGHI
    }
}

\end{minipage}

\vspace{20mm}
\begin{center}

{\large
    {\bf Sessione\\
        III sessione
        2021-2022
    }
}%2018-2019

\end{center}

\end{titlepage}

\textwidth=450pt\oddsidemargin=0pt

\section{Introduzione}

%TODO: dove viene descritto il problema, la subsection può essere rimossa
\subsection{Il linguaggio}

\subsection{Haskell come modello}
Il compilatore è stato sviluppato mediante il linguaggio \textit{Haskell}, anch'esso linguaggio di programmazione funzionale.
Inoltre, il linguaggio target di langgg è \textit{Core}, un formalismo fortemente basato su \textit{System F}, una
variante tipata del lambda-calcolo che introduce un meccanismo di quantificazione universale sui tipi. Core, inoltre,
viene utilizzato da GHC (compilatore Haskell) come rappresentazione intermedia di Haskell. All'interno di questo
contesto, GHC espone delle API che permettono al cliente di utilizzare le funzionalità del compilatore (cfr. [2]); è quindi
possibile creare e manipolare programmi Core mediante le API, le quali sono state scritte in Haskell. Per quest'ultimo
motivo, Haskell è stato scelto come linguaggio di implementazione del compilatore di langgg, tuttavia, nel contesto
del progetto, Haskell ha anche un altro importante ruolo: alcune delle sue funzionalità sono state, direttamente
o indirettamente, fonte di ispirazione per il design di langgg. Nel prossimo paragrafo vengono presentate le principali
caratteristiche di langgg ed è possibile ritrovare la maggior parte di esse anche in Haskell. Un altro linguaggio
che è stato fonte di ispirazione, ma con minore impatto, è \textit{OCaml}, linguaggio multi-paradigma (funzionale non
puro), soprattutto per la sintassi di langgg e per il costrutto delle polymorphic variants (cfr. paragrafo sugli
sviluppi futuri).

\subsection{Caratteristiche del linguaggio}
Tra le principali caratteristiche del linguaggio vi sono:
\begin{description}
\item[Linguaggio funzionale puro] Come Haskell, langgg è un linguaggio funzionale puro. La nozione di linguaggio
di programmazione \textit{funzionale} è piuttosto lasca e non vi è una vera e propria definizione formale,
tant'è che il termine viene spesso utilizzato (e, talvolta, abusato) per indicare un linguaggio avente alcune
particolari specifiche attribuibili al paradigma di programmazione funzionale. langgg può essere quindi considerato
funzionale poiché, semplicemente, ha numerose caratteristiche proprie del paradigma funzionale, quali: tipi di dati
algebrici, pattern matching, funzioni di ordine superiore, immutabilità, polimorfismo parametrico etc.. Per quanto
riguarda la nozione di \textit{purità}, nel paradigma funzionale viene fatta spesso la distinzione
tra linguaggi puri e impuri; anche qui, non vi sono vere e proprie definizioni e la questione è spesso oggetto di
controversie. Una proposta di definizione è stata fornita da Amr Sabry in [1]: la purità ha a che fare con il passaggio
dei parametri, in particolare, un linguaggio L può essere
considerato puro se, dato un qualsiasi programma p scritto in L, le funzioni di p sono dei "\textit{mapping}" puri
dai valori in input ai valori in output, indipendentemente dal tipo di passaggio dei parametri.
\item[Type-system statico con type-inference] langgg è un linguaggio con type-system statico, inoltre, la fase di
type-checking garantisce la proprietà di type-safety. Il linguaggio permette anche di omettere le indicazioni di
tipo (type-hinting) nella definizione di simboli; in caso non vi sia type-hinting per la definizione di un simbolo,
il compilatore inferirà il tipo "più generale possibile" per il simbolo.
\item["Everything is an expression"] tutti i costrutti all'interno di langgg possono essere considerati espressioni
prive di side-effects; non vi sono costrutti di controllo o costrutti che modificano variabili di stato esterne
al contesto locale. I costrutti principali sono:
    \begin{enumerate}
    \item definizioni di: tipi, variabili, proprietà (che corrispondono alle type-classes di Haskell), istanze di
    proprietà, alias di tipi, firme di simboli; le definizioni di simboli hanno le seguenti grammatiche:
    \begin{lstlisting}
      S :=
          let var args = E

     MS :=
          let var MPM
    \end{lstlisting}
    \item espressioni date dalla seguente grammatica:
    \begin{lstlisting}
      E :=
          var
          datacon
          literal
          E E
          lam args -> E
          lam MPM
          S in E
          MS in E
          match E with PM

     PM :=
          ME -> E | ... | ME -> E

    MPM :=
          | ME ... ME = E | ... | ME ... ME = E

     ME :=
          var
          _
          literal
          datacon ME ... ME
          
    \end{lstlisting}
    \item un costrutto, valutato a compile-time (cfr. parsing degli operatori), per definire una "categoria" di
    operatori. Le categorie di operatori hanno degli identificatori per poterle nominare, inoltre definiscono le
    seguenti proprietà:
        \begin{enumerate}
        \item una lista di operatori appartenenti alla proprietà. Sono compresi gli identificatori di variabili (gli
        operatori stessi sono identificatori di variabili) che possono essere utilizzati con la sintassi degli operatori;
        \item una lista di categorie di operatori i quali avranno meno precedenza degli operatori della categoria
        corrente;
        \item una lista di categorie di operatori i quali avranno più precedenza degli operatori della categoria
        corrente;
        \item la fissità degli operatori.
        \end{enumerate}
        %TODO: aggiungi pezzo di codice per mostrare il costrutto
    \end{enumerate}
\item[Tipi di dati algebrici] langgg supporta anche i tipi di dati algebrici (che sono l'unico modo per definire nuovi
tipi). Con essi, vi è anche la nozione di \textit{data constructor}, ovvero un costrutto dotato di tipo che può essere
accompagnato da dati. Per eseguire operazioni con i tipi di dati algebrici vi è il costrutto del pattern matching
(cfr. grammatica delle espressioni) che permette di destrutturare un data constructor dai suoi dati associati.
\item[Polimorfismo parametrico] il sistema di tipi del linguaggio supporta le variabili di tipo. Questo tipo di
polimorfismo permette di avere singoli algoritmi per una moltitudine di tipi.
\item[Kind] Il linguaggio ha la nozione di \textit{kind} e permette la manipolazione di tipi di kind differenti.
Quindi, data la seguente definizione di tipo:
\begin{lstlisting}
type M a b = DataCon1 a | DataCon2 b | DataCon3 a Char
\end{lstlisting}
dove \textit{a} e \textit{b} sono variabili di tipo, è possibile, ad esempio, avere tipi della forma:
\begin{lstlisting}
M Int Char
M a b
M String
M x
M
\end{lstlisting}
\`E possibile altresì avere un tipo della forma:
\begin{lstlisting}
m Int
\end{lstlisting}
dove \textit{m} è una variabile di tipo a cui viene applicata il tipo \textit{Int}.
\item[Polimorfismo ad hoc] attraverso il meccanismo delle type-classes (all'interno del linguaggio vengono chiamate
proprietà), è possibile creare funzioni polimorfe che possono essere applicate ad argomenti di tipi differenti e, a
seconda dei tipi degli argomenti, viene "selezionata" la giusta implementazione. Ogni proprietà può avere uno, ma anche
più tipi associati; inoltre, i tipi associati alle proprietà possono essere anche variabili di tipo.

\end{description}

\section{Il compilatore}

\subsection{La struttura}
\begin{tikzpicture}[node distance=2cm]
\node (src) [object] {Codice sorgente};
\node (parser) [process, below of=src] {Parser};
\draw [arrow] (src) -- (parser);
\node (checker) [process, below of=parser] {Checker della correttezza};
\draw [arrow] (parser) -- (checker);
\node (typedBuilder) [process, below of=checker] {Costruzione dei token tipati};
\draw [arrow] (checker) -- (typedBuilder);
\node (prepare) [process, below of=typedBuilder] {Preparazione alla type inference};
\draw [arrow] (typedBuilder) -- (prepare);
\node (typeInf) [process, below of=prepare] {Type inference - type checking};
\draw [arrow] (prepare) -- (typeInf);
\node (CoreGen) [process, below of=typeInf] {Generazione codice Core};
\draw [arrow] (typeInf) -- (CoreGen);
\node (backend) [process, below of=CoreGen] {Backend};
\draw [arrow] (CoreGen) -- (backend);
\node (exe) [process, below of=backend] {Eseguibile};
\draw [arrow] (backend) -- (exe);
\node (desugar) [process, right of=prepare, xshift=7cm] {Desugaring};
\draw [arrow] (desugar) -- (checker);
\draw [arrow] (desugar) -- (typedBuilder);
\draw [arrow] (desugar) -- (prepare);
\draw [arrow] (desugar) -- (typeInf);
\draw [arrow] (desugar) -- (CoreGen);
\end{tikzpicture}

La struttura del compilatore è sequenziale, con eccezione fatta per la fase di \textit{desugaring}. Quest'ultima si
occupa di rimuovere il cosiddetto "zucchero sintattico" dalle strutture dati - che mantengono le informazioni del
programma - che, durante le varie fasi di compilazione, possono subire semplificazioni. Talvolta, alcune semplificazioni
vengono posticipate il più possibile per permettere al compilatore di restituire in output messaggi d'errore comprensibili
per l'utente. Un esempio ne è la trasformazione che subiscono le strutture dati che rappresentano il costrutto del
pattern matching. Il modulo che si occupa del desugaring si presenta come una libreria che espone delle API che agiscono
sulle strutture dati del compilatore. \`E compito del compilatore fare le chiamate al modulo di desugaring. Di seguito,
vi è una più ampia e precisa descrizione delle singole fasi di compilazione, con enfasi particolare sugli algoritmi
più interessanti utilizzati per risolvere i singoli sottoproblemi e su come le varie fasi interagiscono tra loro.

\section{L'albero di sintassi astratta}
Nella prima parte del compilatore viene eseguito il parsing del sorgente.
Questa operazione produce quindi l'albero di sintassi astratta (AST). Il codice che gestisce i "token" dell'AST è
all'interno del modulo \texttt{Compiler.Ast.Tree}; l'entry point dell'albero è dato dal token \texttt{Program}, il
quale, come nodi figli, ha delle \texttt{Declaration} che rappresentano i vari costrutti del linguaggio.

\begin{lstlisting}
newtype Program a = Program [Declaration a]

data Declaration a =
      ADT (AlgebraicDataType a)
    | AliasADT (AliasAlgebraicDataType a)
    | Intf (Interface a)
    | Ins (Instance a)
    | Sig (Signature a)
    | Let (SymbolDeclaration a)
    | LetMulti (MultiSymbolDeclaration a)
\end{lstlisting}

Di seguito vi è lo schema della prima parte del compilatore:

\begin{tikzpicture}[node distance=2cm]
\node (src) [object] {Codice sorgente};
\node (rawast) [object, below of=src] {Albero di sintassi astratta};
\draw [arrow] (src) -- node[anchor=west] {Parser} (rawast);
\node (rawastBuiltin) [object, below of=rawast] {Albero di sintassi astratta};
\draw [arrow] (rawast) -- node[anchor=west] {Aggiunta token built-in} (rawastBuiltin);
\node (rawastNames) [object, below of=rawastBuiltin] {Albero di sintassi astratta};
\draw [arrow] (rawastBuiltin) -- node[anchor=west] {Check esistenza dei nomi} (rawastNames);
\node (rawastArgs) [object, below of=rawastNames] {Albero di sintassi astratta};
\draw [arrow] (rawastNames) -- node[anchor=west] {Check numero degli argomenti} (rawastArgs);
\node (rawastAlias) [object, below of=rawastArgs] {Albero di sintassi astratta};
\draw [arrow] (rawastArgs) -- node[anchor=west] {Sostituzione degli alias di tipo} (rawastAlias);
\node (desugar) [object, right of=rawastAlias, xshift=7cm] {Desugaring};
\draw [arrow] (desugar) -- (rawastAlias);
\end{tikzpicture}

\subsection{Il parser}
Il parser è la prima componente del compilatore (dopo la lettura del sorgente). \`E stato scritto mediante la libreria
open-source \texttt{Parsec} [4], la quale si basa sul concetto di parser combinator monadico. Il codice risiede nel
modulo \texttt{Compiler.Syntax} ed ha una struttura gerarchica: parte definendo i combinators di "pezzi" primitivi dei
token dell'AST (\texttt{Compiler.Syntax.Lib.SimpleParser}), dopodiché, nel modulo \texttt{Compiler.Syntax.Grammar} vi
è la generazione vera e propria dei token dell'AST e, infine, vi è l'entry point del parser, ovvero
\texttt{Compiler.Syntax.Parser}. \`E bene notare che all'interno del modulo \texttt{Compiler.Syntax.Lib.SimpleParser}
non sono visibili le API dell'AST, in quanto esso si occupa soltanto del parsing dei costrutti del linguaggio e non
della generazione dei token.

\subsubsection{Parsing degli operatori}
langgg permette di definire operatori che vengono trattati come simboli di variabili (funzioni). In questo contesto,
il linguaggio espone all'utente un costrutto particolare che permettere di definire le proprietà degli eventuali
operatori. Questo costrutto viene valutato durante il parsing e definisce una categoria di operatori, ecco un esempio:

\begin{lstlisting}
OPERATORS_CATEGORY {#
    name : Application ;
    operators : |>, <|, `applyTo ;
    lesser than : Comparison, Numeric ;
    greater than : Functor ;
    fixity : InfixLeft ;
#}
\end{lstlisting}

Il primo "campo" è il nome della categoria ed è utile per poter identificare la categoria, infatti, il terzo e il
quarto campo definiscono rispetto a quali categorie gli attuali operatori hanno precedenza. Il secondo campo definisce
l'insieme di operatori che fanno parte della categoria. Infine, l'ultimo campo è una costante e definisce la fissità
degli operatori: infissa senza associazione, infissa con associazione a sinistra, infissa con associazione a destra,
postfissa o prefissa. La versione infissa è solo per gli operatori binari, mentre postfissa e prefissa solo per gli
operatori unari. Si può notare che nella lista di operatori vi è anche un simbolo di variabile preceduto dal simbolo
di backtick; questo è possibile, in quanto langgg permette di utilizzare i simboli di variabili come operatori
facendoli precedere dal carattere backtick. La valutazione di questo costrutto è interamente integrata nel parser ed
è obbligatorio per l'utente definire le categorie degli operatori all'inizio del sorgente. La libreria \texttt{Parsec}
offre delle API anche per il parsing degli operatori; l'algoritmo di gestione delle categorie si occupa di costruire
una tabella di operatori, implementata semplicemente come una lista di liste, ordinando i gruppi (di categorie) in
base alla loro precedenza. Le informazioni sulle categorie vengono estrapolate dal parsing del costrutto e vengono
passate successivamente all'algoritmo di ordinamento delle categorie. Quest'ultimo si può ridurre all'inserimento
di un elemento in una lista di liste:

\begin{lstlisting}
insert(x, ll):
    match ll with
        [] -> [[x]]
        (l :: lt) ->
            if any x' in l. x' < x        // Condizione d'inserimento (1)
            then
                if areAmbigous(x, ll)
                then fail
                else [x] :: l :: lt
            else if all x' in l. x' == x  // Condizione d'inserimento (2)
            then
                if areAmbigous(x,ll)
                then fail
                else subInsert(x, l) :: lt
            else l :: insert(x, lt)
\end{lstlisting}

L'algoritmo scorre la lista finché non:
\begin{enumerate}
    \item trova una sottolista \textit{l} in cui esiste almeno un elemento minore di \textit{x}; in questo caso, controlla
    eventuali ambiguità delle categorie, poiché l'utente potrebbe aver definito categorie tali che la nozione di
    ordinamento tra loro non è transitiva. La funzione \texttt{areAmbigous} nel pezzo di pseudocodice si occupa
    di eseguire questo controllo. Se non esistono ambiguità tra le categorie, allora viene creata una nuova lista
    singoletto contenente \textit{x} che viene inserita davanti alla sottolista \textit{l}
    \item trova una sottolista \textit{l} in cui tutti gli elementi sono uguali a \textit{x}; in questo caso, \textit{x}
    viene inserito in \textit{l}, eseguendo sempre prima il controllo sulle ambiguità.
\end{enumerate}
In tutti gli altri casi, la corrente sottolista \textit{l} contiene almeno un elemento $ x' $ tale che
$ x' > x $, quindi l'inserimento non può ancora avvenire. Quando la tabella è completa, essa viene passata alla
funzione \texttt{buildExpressionParser} della libreria \texttt{Parsec} che si occupa di costruire il parser per le
espressioni.

\subsection{Check dei nomi}
Dopo la fase di parsing e dell'aggiunta di token built-in del linguaggio (ad esempio, alcuni operatori aritmetici),
viene effettuato il controllo di esistenza di ogni tipo di simbolo: nomi di tipo, nomi di variabili, nomi di proprietà,
etc.. Perciò deve valere la seguente condizione:
    \[ \forall name \in AST. \exists def(name) \]
dove \textit{def} è la funzione che ritorna la definizione di un token dell'AST.
Questo tipo di check è molto importante in quanto fasi successive del compilatore basano le loro computazioni
sull'ipotesi che tutti i simboli sono stati definiti. Il codice risiede nel modulo \texttt{Compiler.Args}.

\subsection{Check degli argomenti}
Il controllo degli argomenti viene effettuato, a differenza del check dei nomi che viene eseguito su ogni tipo di nome,
solo sui nomi di tipo, di alias e di proprietà. In particolare, devono valere le seguenti condizioni:
\[ \forall name \in AST. \]
\begin{enumerate}
    \item:
        \[ isTypeName(name) \Longrightarrow \# args(name) \leq \#args(def(name)) \]
    \item:
        \[ isAliasName(name) \Longrightarrow \#args(name) = \#args(def(name)) \]
    \item:
        \[ isPropertyName(name) \Longrightarrow \#args(name) = \#args(def(name)) \]
\end{enumerate}
dove \textit{isTypeName}, \textit{isAliasName}, \textit{isPropertyName} sono le funzioni che ritornano \textit{true}
se il nome in input è, rispettivamente, un nome di tipo, un nome di alias, un nome di proprietà, \textit{false} altrimenti,
\textit{args} è la funzione che calcola gli argomenti di un token e il simbolo \textit{\#} è la funzione che calcola
la cardinalità di un insieme. La condizione (1) è meno stringente di (2) e di (3),
in quanto l'utente può "manipolare" non solo tipi, ma anche funzioni di tipi,
anche conosciute come \textit{type constructor}. La condizione (2) è fondamentale per la prossima fase del compilatore.
Il codice risiede nel modulo \texttt{Compiler.Desugar.Args}.

\subsection{Eliminazione degli alias di tipo}
langgg offre un costrutto che permette all'utente di definire alias di tipi. Ecco un esempio:

\begin{lstlisting}
alias CharAnd x = Tuple2 Char x
\end{lstlisting}

Questo tipo di costrutto viene completamente valutato in fase di compilazione: ogni occorrenza di nome di alias viene
trattata come una vera e propria macro, quindi viene sostituita con il tipo associato all'alias. Il modulo di Desugaring
si occupa di questo task (\texttt{Compiler.Desugar.Alias}).
Come si nota nell'esempio, gli alias ammettono argomenti (variabili di tipo) che vengono passati alla funzione di tipo.
Il linguaggio ammette anche alias di alias, tuttavia, ciò può portare a \textit{cicli} di alias, come ad esempio:

\begin{lstlisting}
alias A = B
alias B = C
alias C = A
\end{lstlisting}

Per questo motivo, l'algoritmo di sostituzione degli alias implementa anche la "cycle detection". Inoltre, nella
sostituzione è fondamentale che valga la condizione sugli alias nel check degli argomenti (cfr. check degli argomenti):
    \[ \forall name \in AST. isAliasName(name) \Longrightarrow \#args(name) = \#args(def(name)) \]
Se la sopracitata condizione non fosse vera, non sarebbe possibile effettuare l'unificazione nella kind-inference (cfr.
kind-inference).

\subsection{Eliminazione delle firme di funzioni}
langgg espone un costrutto, detto \textit{signature} (in italiano "firma"), che permette di indicare il tipo di un
binding. Ad esempio:

\begin{lstlisting}
val id : a -> a
\end{lstlisting}

L'esempio appena mostrato indica che la variabile \textit{id} ha tipo $ \forall \alpha. \alpha \mapsto \alpha $. Questo
tipo di costrutto non è nient'altro che "zucchero sintattico" per il type-hinting dei binding. I token dei binding
- \texttt{SymbolDeclaration} e \texttt{MultiSymbolDeclaration} - possono possedere delle informazioni sul type-hinting,
ad esempio, guardando la definizione di \texttt{MultiSymbolDeclaration}:

\begin{lstlisting}
data MultiSymbolDeclaration a =
    MultiSymTok (SymbolName a) (Hint a) (MultiPatternMatch a) a
\end{lstlisting}

si può notare che il costruttore \texttt{MultiSymTok} prenda in input un token \texttt{Hint}. Il task del modulo
\texttt{Desugar.Sigs} è di eliminare dall'AST i costrutti \texttt{Signature} che rappresentano, appunto, le firme delle
variabili e aggiungere la loro informazione sul tipo come type-hinting delle definizioni delle variabili.

\section{Generazione dei token "tipati"}
Dopo la generazione dell'albero di sintassi astratta e alcune fasi di desugaring, questa seconda macro componente del
compilatore si occupa della generazione dei token "tipati". Questi ultimi prendono questa nomea in quanto, a questo
livello, compaiono le nozioni di tipo e di kind del linguaggio.

\begin{tikzpicture}[node distance=2cm]
\node (desast) [object] {AST "dezuccherato"};
\node (desastContsCheck) [object, below of=desast] {AST "dezuccherato"};
\draw [arrow] (desast) -- node[anchor=east] {Check dei constraints} (desastContsCheck);
\node (typesTable) [object, below of=desastContsCheck] {Tabella dei tipi};
\draw [arrow] (desastContsCheck) -- node[anchor=east] {Kind-inference} (typesTable);
\node (consTable) [object, below of=typesTable] {Tabella dei costrutturi};
\draw [arrow] (typesTable) -- node[anchor=east] {Costruzione dei data constructor} (consTable);
\node (contsTable) [object, below of=consTable] {Tabella dei constraints o predicati};
\draw [arrow] (consTable) -- node[anchor=east] {Costruzione dei constraints} (contsTable);
\node (instances) [object, below of=contsTable] {Tabelle di: metodi di proprietà; metodi di istanza; istanze};
\draw [arrow] (contsTable) -- node[anchor=east] {Valutazione delle istanze di proprietà} (instances);
\node (bindings) [object, below of=instances] {Bindings dell'AST pronti per la type-inference};
\draw [arrow] (instances) -- node[anchor=east] {"Preparazione" alla type-inference} (bindings);
\node (tyBindings) [object, below of=bindings] {Bindings tipati};
\draw [arrow] (bindings) -- node[anchor=east] {type-inference} (tyBindings);
\node (desugar) [object, right of=bindings, xshift=6cm] {Desugaring};
\draw [arrow] (desugar) -- (instances);
\draw [arrow] (desugar) -- (bindings);
\draw [arrow] (desugar) -- (tyBindings);
\end{tikzpicture}

\subsection{Approccio a tabelle}
A differenza della prima macro componente del compilatore, dove l'unica struttura dati di primo livello era l'AST, in
questo caso vi sono molteplici strutture dati di primo livello. Innanzitutto, nel modulo \texttt{Ast.Typed}, vi sono
le definizioni di tutti i token tipati e le operazioni su di essi; proprio in questo modulo compaiono:
\begin{enumerate}
    \item le nozioni che riguardano i tipi del linguaggio:
    \begin{lstlisting}
data LangKind               --kind
data LangVarType a          --variabile di tipo
data LangHigherType a       --mono-tipo
data LangSpecConstraint a   --"constraint" o predicato
data LangQualType a         --mono-tipo qualificato
data LangTypeScheme a       --poli-tipo o schema di tipo
    \end{lstlisting}
    \item i token tipati che costituiscono un programma:
    \begin{lstlisting}
data NotedVar a           --variabili
data NotedVal a           --valori: letterali e data constructor
data NotedMatchExpr a     --espressioni per il pattern match
data NotedExpr a          --expressioni
    \end{lstlisting}
    \item operazioni che riguardano la manipolazione dei tipi quali unificazione, test di specificità, specializzazione,
    instanziazione, generalizzazione. Inoltre, vi sono le funzioni e le strutture dati per gestire il dispatch statico.
\end{enumerate}
Nonostante la presenza di token tipati, non esiste una corrispondente versione tipata dell'AST con un unico entry point,
bensì le informazioni che riguardano un programma vengono memorizzate in "tabelle" (cfr. modulo \texttt{Types.Tables}):
\begin{lstlisting}
newtype TypesTable a          --tabella dei "modelli" di tipi
newtype DataConsTable a       --tabella dei data constructor
newtype ConstraintsTable a    --tabella dei "modelli" di constraints
newtype InstsTable a          --tabella dei bindings delle istanze
newtype PropMethodsTable a    --tabella dei metodi di proprieta'
newtype ImplTable a           --tabella delle istanze
data    TypedProgram a        --tabella dei bindings tipati
\end{lstlisting}
Vedremo nel dettaglio ogni tabella nelle descrizioni delle varie fasi del compilatore. Tuttavia, è necessaria una nota
su \texttt{TypesTable} e \texttt{ConstraintsTable}. Come si legge dai commenti, esse sono tabelle per memorizzare dei
"modelli". Tali modelli sono necessari alla costruzione dei tipi e dei predicati all'interno di un programma. Ad esempio,
date le seguenti definizioni in langgg:
\begin{lstlisting}
type Box a = Boxing a
property Stateful m =
    val getState : m a -> a
;;
\end{lstlisting}
Verranno creati dei token (presenti in \texttt{Ast.Typed}) dei tipi:
\begin{lstlisting}
data LangNewType a            --"modello" di tipo o type constructor
data LangNewConstraint a      --"modello" di constraint
\end{lstlisting}
che rappresenteranno rispettivamente il modello per tipi \texttt{Box} e il modello per constraints \texttt{Stateful} e che
verranno memorizzati nelle suddette tabelle.

Sempre nel modulo \texttt{Types.Tables}, viene definito anche il cosiddetto "binding tipato":
\begin{lstlisting}
type BindingSingleton a = (NotedVar a, [NotedVar a], NotedExpr a)
data TypedBinding a =
      TyNonRec (BindingSingleton a)
    | TyRec [BindingSingleton a]
\end{lstlisting}
Osservando l'implementazione di \texttt{TypedBinding}, si nota come esistano due tipi di binding. Il primo è per i binding
non ricorsivi, mentre il secondo è per i binding che sono mutualmente ricorsivi fra loro (cfr. type-inference).

\subsubsection{Confronto con GHC}
Come è stato detto precedentemente, l'approccio del compilatore è quello di costruire tabelle man mano che le informazioni
vengono inferite dall'AST. GHC (the Glasgow Haskell Compiler) utilizza un approccio differente, in quanto non utilizza
alcuna "symbol table", bensì ogni token tipato (di GHC) nella compilazione di un programma Haskell da parte di GHC può
textit{puntare} ad altri token tipati [5]. Si crea così un grafo di strutture dati tipate. Ad esempio, GHC, per gestire
le entità di type constructor e data constructor, utilizza rispettivamente i token \texttt{TyCon} e \texttt{DataCon} (si
ricordi che GHC è scritto in Haskell):
\begin{lstlisting}
data TyCon
data DataCon
\end{lstlisting}
Ogni token di tipo \texttt{TyCon} punterà a una lista di \texttt{DataCon} che, a loro volta, conterranno la referenza
al loro costruttore di tipo. Come puntualizza Edward Y. Zang nell'introduzione dell'articolo [6],
uno svantaggio di questo approccio è che il grafo è immutabile e quindi, per poter
aggiornare i nodi del grafo è necessario ricostruire il grafo da zero. Tuttavia, questo problema è mitigato, in quanto
gli aggiornamenti del grafo sono parecchio rari, inoltre, man mano che GHC ottiene informazioni dal programma Haskell,
accrescerà il grafo senza aggiornare i nodi preesistenti; in questo modo, non vi è alcuna necessità di costruire il
grafo da zero.

\subsection{Polimorfismo ad hoc}
langgg supporta il polimorfismo ad hoc esponendo costrutti chiamati \textit{proprietà}, le quali sono concettualmente
molto simili alle \textit{type classes} di Haskell. Ecco un esempio di definizione di proprietà in langgg:
\begin{lstlisting}
property Stream s t =
    val new : t -> s t
    val yield : t -> s t -> s t
    val consume : s t -> Tuple2 (s t) t
;;
\end{lstlisting}
Questo pezzo di codice produce idealmente tre token corrispondenti ai metodi \texttt{new}, \texttt{yield} e \texttt{consume},
i quali possono essere istanziati attraverso il meccanismo delle istanze che verrà presentato prossimamente. I tre
token appena costruiti avranno le seguenti firme:
\begin{lstlisting}
val new : Stream s t => t -> s t
val yield : Stream s t => t -> s t -> s t
val consume : Stream s t => s t -> Tuple2 (s t) t
\end{lstlisting}
Si noti come le firme effettive non siano le stesse di quelle date dall'utente, le quali risultano incomplete.
All'inizio della dicitura dei tipi effettivi, si può notare un \textit{constraint} o \textit{predicato} seguito da una
freccia, la quale è intesa come implicazione. I tipi dei metodi di proprietà avranno quindi la forma:
\[ Pred(\overline{\alpha}) \Longrightarrow ty(\overline{\alpha}) \]
dove \textit{Pred} è un predicato e \textit{ty} è una funzione di tipo.
Il polimorfismo ad hoc viene, dunque, supportato attraverso i predicati, i quali rappresentano delle ipotesi aggiuntive
sui tipi. L'istanziazione di una proprietà consiste nel dichiarare dei tipi che %TODO

\subsection{Kind-inference}
%TODO

\section*{Bibliografia}
\begin{enumerate}[label={[\arabic*]}]
    %[1]
    \item Amr Sabry - What is a purely functional language? - in: Journal of Functional Programming, Volume 8, Issue 1,
    January 1998, pp. 1 - 22
    %[2]
    \item Martin Sulzmann, Martin Odersky, Martin Wehr - Type Inference with Constrained Types - in: Theory and Practice
    of Object Systems · January 1999
    %[3]
    \item Stephen Diehl - Dive into GHC: Targeting Core - url: \url{https://www.stephendiehl.com/posts/ghc_03.html}
    %[4]
    \item libreria Parsec - url: \url{https://hackage.haskell.org/package/parsec}
    %[5]
    \item Data types for Haskell entities - url:
    \url{https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/entity-types}
    %[6]
    \item Edward Y. Zang - Backpack without symbol tables - in: May 11, 2016 - url:
    \url{http://web.mit.edu/~ezyang/Public/backpack-symbol-tables.pdf}
\end{enumerate}

\end{document}
